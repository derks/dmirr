# -*- coding: utf-8 -*-
import os
from tg import expose, validate, flash, url, request, redirect, config, require
from pylons.controllers.util import abort
from pylons.i18n import ugettext as _
from pylons import response 
from socket import gaierror

import geopy
from geopy import geocoders, distance
import pygeoip
import re
from beaker.cache import CacheManager
from beaker.util import parse_cache_config_options

from dmirr import model as model
from dmirr.model import DBSession as db
from dmirr.lib.base import BaseController
from dmirr.model.product import ProductRelease, Arch

__all__ = ['MirrorListController']

#FIXME: Need to figure out how to make using memcache, and other cache types
#easily configurable.
cache_opts = {
    'cache.type': config['cache_type'],
    'cache.data_dir':  os.path.join(config['beaker.cache.data_dir'], 'data'),
    'cache.lock_dir': os.path.join(config['beaker.cache.data_dir'], 'lock')
    }
cache = CacheManager(**parse_cache_config_options(cache_opts))

class MirrorListController(BaseController):
    @cache.cache('mirrorlist_func', expire=int(config['mirrorlist_expire_time']))
    def _get_mirror_list(self, client_addr=None, release_label=None, arch_label=None):
        o_list = [] # ordered list
        arch = db.query(model.Arch).filter_by(label=arch_label)\
               .first()
        release = db.query(model.ProductRelease)\
               .filter_by(label=release_label).first()
            
        if not release:
            abort(404)
            
        if not arch in release.archs:
            abort(404)
        
        # get geoip data of requesting client
        gic = pygeoip.GeoIP(config['geo_city_file'])
        gn = geocoders.GeoNames()
        
        req_geoip = None
        try:
            req_geoip = gic.record_by_addr(client_addr)
        except gaierror, e:
            pass
        
        # generate the list
        if not req_geoip:
            # no geoip available
            txt = "# Mirror List generated by dMirr\n"
            host_count = 0
            break_out = False
            for site in release.product.project.sites:
                if break_out:
                    break
                for host in site.hosts:
                    host_count += 1
                    host_line = "http://%s%s%s\n" % (host.address, 
                        release.product.project._sync_path(site.id), 
                        release.path)
                    host_line = re.sub('\$ARCH', arch.label, host_line)
                    txt += str(host_line)
                    if host_count >= int(config['mirrorlist_max_results']):
                        break_out = True
                        break
        else:
            req_city = req_geoip.get('city', None)
            req_region = req_geoip.get('region_name', None)
            req_country = req_geoip.get('country_name', None)
            loc = self._get_location(req_city, req_region, req_country)
            if req_geoip.has_key('longitude') and req_geoip.has_key('latitude'):
                req_place = (req_geoip['latitude'], req_geoip['longitude'])
            else:
                loc_all = gn.geocode(loc, exactly_one=False)
                try:
                    req_place = loc_all.next()[1] # get the first one in the list
                except StopIteration, e:
                    req_place = (0.0, 0.0) 
            
            txt = "# Mirror List generated by dMirr - ordering for %s\n" % loc
            host_count = 0
            break_out = False
            for site in release.product.project.sites:
                if break_out:
                    break
                for host in site.hosts:
                    host_count += 1
                    h_place = (host.latitude, host.longitude)
                    dist = distance.distance(req_place, h_place).miles
                    sync_base_path = release.product.project._sync_path(site.id)
                    o_list.append((dist, host, sync_base_path))
                    if host_count >= int(config['mirrorlist_max_results']):
                        break_out = True
                        break
                        
            o_list.sort()
            for (dist, host, sync_base_path) in o_list:
                host_line = "http://%s%s%s\n" % (host.address, 
                                                 sync_base_path, 
                                                 release.path)
                host_line = re.sub('\$ARCH', arch.label, host_line)
                txt += str(host_line)
        return txt
        
        
    def _get_location(self, city=None, region=None, country=None):
        if city and region and country:
            location = "%s, %s %s" % (city, region, country)
        elif region and country:
            location = "%s %s" % (region, country)
        elif country:
            location = country
        else:
            location = 'US'
        return location
        
        
    @expose(content_type='text/plain')
    def index(self, *a, **kw):
        release = kw.get('release', None) # new style
        repo = kw.get('repo', None) # old style to support mirror manager
        arch = kw.get('arch', None)
        client_addr = request.environ['REMOTE_ADDR']
        if not release and repo:
            release = repo
            
        txt = self._get_mirror_list(client_addr, release, arch)    
        return txt
        
